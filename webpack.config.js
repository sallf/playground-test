const webpack = require('webpack');
const path = require('path');

// PLUGINS
const HtmlWebpackPlugin = require('html-webpack-plugin'); // simplifies HTML files for webpack (really connects to the index.ejs file)
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin'); // remove/clean your build folder(s)
const CopyWebpackPlugin = require('copy-webpack-plugin'); // Copies assets which aren't required (like pdfs)
const TerserPlugin = require('terser-webpack-plugin'); // Helps with minification
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin'); // Extra minifies all css and removes comments
const CssNano = require('cssnano');

const resolveConfig = require('./webpack.config.resolve');

module.exports = (env, argv) => {
  const { mode } = argv;

  // Note: mode is used as a flag
  // env is used to connect to the proper files in ./config

  // MODE
  const isProduction = mode === 'production';
  const isDevelopment = mode === 'development';

  // RESOLVE
  const contextPath = path.resolve(__dirname, 'src');
  const outputPath = path.resolve(__dirname, 'public');

  const scssModuleRegex = /(components|screens|App).*\.scss$/;

  console.info(
    `Environment: ${env} - Mode: ${mode}`,
  );

  // Plugins
  const htmlWebpackPlugin = new HtmlWebpackPlugin({
    title: 'TODO',
    template: './index.ejs',
    inject: true, // Inject all files that are generated by webpack
    minify: false,
  });

  const miniCssExtractPlugin = new MiniCssExtractPlugin({
    filename: isDevelopment ? '[name].css' : '[name].[contenthash].css',
  });

  const cleanWebpackPlugin = new CleanWebpackPlugin();

  const copyWebpackPlugin = new CopyWebpackPlugin({
    patterns: [
      { from: 'assets/public', to: 'public' },
    ],
  });

  const ignorePlugin = new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/);

  const optimizeCssAssetsPlugin = new OptimizeCssAssetsPlugin({
    assetNameRegExp: /\.css$/g,
    cssProcessor: CssNano,
    cssProcessorPluginOptions: {
      preset: ['default', { discardComments: { removeAll: true } }],
    },
    canPrint: true,
  });

  const plugins = [
    miniCssExtractPlugin,
    htmlWebpackPlugin,
    ignorePlugin,
    copyWebpackPlugin,
  ];

  if (isProduction) {
    plugins.push(
      cleanWebpackPlugin,
      optimizeCssAssetsPlugin,
    );
  }

  return ({
    context: contextPath,
    devtool: isDevelopment ? 'inline-sourcemap' : false,
    entry: {
      'src/index.jsx': [
        path.join(__dirname, './src/index.jsx'),
      ],
    },
    resolve: {
      alias: {
        ...resolveConfig.resolve.alias,
        config: path.resolve(__dirname, 'config', env),
      },
      extensions: ['*', '.js', '.json', '.jsx'],
    },
    module: {
      rules: [
        {
          test: /\.(js|jsx)$/,
          include: [
            path.resolve(__dirname, 'src'),
            path.resolve(__dirname, 'tests'),
          ],
          exclude: /node_modules/,
          use: {
            loader: 'babel-loader',
            options: {
              cacheDirectory: true,
            },
          },
        },
        // Help: https://github.com/webpack-contrib/css-loader#separating-interoperable-css-only-and-css-module-features
        // SCSS ALL EXCEPT MODULES
        {
          test: /\.(sc|c)ss$/,
          exclude: scssModuleRegex,
          use: [
            {
              loader: isDevelopment ? 'style-loader' : MiniCssExtractPlugin.loader,
            },
            {
              loader: 'css-loader',
              options: {
                importLoaders: 1,
                modules: {
                  compileType: 'icss',
                },
                sourceMap: isDevelopment,
              },
            },
            {
              loader: 'sass-loader',
              options: {
                sourceMap: isDevelopment,
              },
            },
          ],
        },
        // SCSS MODULES
        {
          test: scssModuleRegex,
          use: [
            {
              loader: isDevelopment ? 'style-loader' : MiniCssExtractPlugin.loader,
            },
            {
              loader: 'css-loader',
              options: {
                importLoaders: 1,
                modules: {
                  localIdentName: `${isDevelopment ? '[local]___' : ''}[hash:base64:5]`,
                  compileType: 'module',
                },
                sourceMap: isDevelopment,
              },
            },
            {
              loader: 'sass-loader',
              options: {
                sourceMap: isDevelopment,
              },
            },
          ],
        },
        {
          test: /\.(ttf|eot|woff|woff2|svg)$/,
          include: path.resolve(__dirname, './src/assets/scss'),
          use: [{
            loader: 'file-loader',
            options: {
              name: '[name].[ext]',
              outputPath: 'fonts/',
            },
          }],
        },
        {
          test: /\.(jpg|png|svg)$/,
          include: path.resolve(__dirname, 'src/assets/images'),
          loader: 'file-loader',
          options: {
            // https://webpack.js.org/loaders/file-loader/#esmodule
            esModule: false,
          },
        },
      ],
    },
    optimization: {
      namedChunks: true,
      minimize: isProduction,
      minimizer: [
        new TerserPlugin({
          // cache: true,
          cache: false,
          parallel: true,
          // sourceMap: isDevelopment, // Must be set to true if using source-maps in production
          sourceMap: true,
          extractComments: false,
          terserOptions: {
            // https://github.com/webpack-contrib/terser-webpack-plugin#terseroptions
            compress: {
              // drop_console: isProduction,
              drop_console: false,
            },
          },
        }),
      ],
    },
    output: {
      filename: '[name].[chunkhash].bundle.js',
      chunkFilename: '[name].[chunkhash].bundle.js',
      path: outputPath,
      publicPath: '/',
    },
    plugins,
    devServer: {
      historyApiFallback: true,
      contentBase: './src',
    },
  });
};
